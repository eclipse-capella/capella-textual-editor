/*******************************************************************************
* Copyright (c) 2020 THALES GLOBAL SERVICES.
*  
*  This program and the accompanying materials are made available under the
*  terms of the Eclipse Public License 2.0 which is available at
*  http://www.eclipse.org/legal/epl-2.0
*  
*  SPDX-License-Identifier: EPL-2.0
*  
*  Contributors:
*     Thales - initial API and implementation
*******************************************************************************/
/*
 * generated by Xtext 2.18.0.M3
 */
package org.polarsys.capella.scenario.editor.dsl.ui.contentassist

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.Assignment
import org.polarsys.capella.scenario.editor.helper.EmbeddedEditorInstanceHelper
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.polarsys.capella.scenario.editor.dsl.textualScenario.Model
import org.polarsys.capella.scenario.editor.dsl.textualScenario.SequenceMessage
import org.polarsys.capella.scenario.editor.dsl.textualScenario.Participant
import org.polarsys.capella.core.model.helpers.CapellaElementExt

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class TextualScenarioProposalProvider extends AbstractTextualScenarioProposalProvider {
	/*
	 * filter the proposed keywords based on the context in which we edit the text scenario;
	 * check the context of the Capella Diagram - layer (OA, SA, LA, PA), type of scenario (IS, ES FS)
	 */
	override completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		if (EmbeddedEditorInstanceHelper.checkValidKeyword(keyword.getValue())) {
			super.completeKeyword(keyword, contentAssistContext, acceptor)
		}
	}

	override completeActor_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("actor", context, acceptor)
	}

	override completeComponent_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("component", context, acceptor)
	}

	override completeConfigurationItem_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("configuration_item", context, acceptor)
	}

	override completeFunction_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("function", context, acceptor)
	}

	override completeActivity_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("activity", context, acceptor)
	}

	override completeEntity_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("entity", context, acceptor)
	}

	override completeRole_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("role", context, acceptor)
	}

	/*
	 * propose a list with the participants (parts that can be created
	 * if we have duplicated names in the list we can chose based on the id
	 */
	def getExistingParticipants(
		String keyword,
		ContentAssistContext context,
		ICompletionProposalAcceptor acceptor
	) {
		for (el : EmbeddedEditorInstanceHelper.getAvailableElements(keyword)) {
			var elementName = CapellaElementExt.getName(el)
			
			// if the name is already inserted in the text, do not propose it
			if (!participantAlreadyInserted(context.rootModel as Model, elementName, keyword)) {
				// create the proposal
				var proposal = createCompletionProposal("\"" + elementName + "\"", elementName, null,
					context) as ConfigurableCompletionProposal
				acceptor.accept(proposal);
			}
		}
	}

	/*
	 * check if a participant is already used in the text
	 */
	def participantAlreadyInserted(Model model, String name, String keyword) {
		for(participant : model.participants) {
			if(participant.keyword == keyword && participant.name == name)
				return true
		}
		return false
	}


	override completeSequenceMessage_Source(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		for (EObject el : variablesDefinedBefore2(model as Model)) {
			acceptor.accept(
				createCompletionProposal("\"" + (el as Participant).name + "\"", (el as Participant).name, null,
					context))
		}
	}

	override completeSequenceMessage_Target(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		for (EObject el : variablesDefinedBefore3(model as SequenceMessage)) {
			acceptor.accept(
				createCompletionProposal("\"" + (el as Participant).name + "\"", (el as Participant).name, null,
					context))
		}
	}

	override completeSequenceMessage_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var sequenceMessage = model as SequenceMessage;
		
		for (String el : messagesDefinedBefore(model as SequenceMessage)) {
			(context.rootModel as Model).messagesOrReferences
			if (!messageAlreadyInserted(context.rootModel as Model, sequenceMessage.source, sequenceMessage.target,
				el)) {
				acceptor.accept(createCompletionProposal("\"" + el + "\"", "\"" + el + "\"", null, context))
			}
		}
	}
	
	/*
	 * check if a message is already used in the text
	 */
	def messageAlreadyInserted(Model model, String source, String target, String name) {
		for(element : model.messagesOrReferences) {
			if(element instanceof SequenceMessage) {
				var message = element as SequenceMessage
				if(message.name == name && message.source == source && message.target == target)
					return true
			}
		}
		return false
	}

	def messagesDefinedBefore(SequenceMessage message) {
		return EmbeddedEditorInstanceHelper.getExchangeNames(message.getSource, message.getTarget)
	}

	def variablesDefinedBefore(Participant sc) {
		return sc
	}

	def variablesDefinedBefore2(Model m) {
		return m.participants
	}

	def variablesDefinedBefore3(SequenceMessage seq) {
		return (seq.eContainer as Model).participants
	}
}
